<?php 

define( 'CONTRIBUTION_AUDIT_WR1_PARSER_DIR', '/usr/local/src/Wr1Parser/' );
define( 'CONTRIBUTION_AUDIT_WR1_FILES_DIR', '/usr/local/src/Wr1_files/' );
define( 'CONTRIBUTION_AUDIT_LOG_FILES_DIR', '/usr/local/src/logs/' );
define( 'CONTRIBUTION_AUDIT_PLUSMINUS', 7 );
define( 'CONTRIBUTION_AUDIT_TEST_MODE', true );
define( 'CONTRIBUTION_AUDIT_FAKE_DB', false );

if ( function_exists( 'drupal_get_path' ) ) {
	require_once( drupal_get_path( 'module', 'queue2civicrm' ) . '/queue2civicrm_stomp.inc' );
}

/**
 * Implementation of hook_menu()
 */
function globalcollect_audit_menu() {
  $items = array();
  
  $items['admin/settings/contribution_audit/globalcollect_audit'] = array(
    'title' => 'Globalcollect Audit Configuration',
    'description' => t('Configure globalcollect audit settings.'),
    'access arguments' => array('administer contribution_audit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'globalcollect_audit_settings' ),
    'type' => MENU_LOCAL_TASK
  );
  
  return $items;
}

/**
 * Callback for menu path "admin/settings/wmf_owa".
 */
function globalcollect_audit_settings() {
  $form['globalcollect_audit_wr1_parser_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WR1 parser classes' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_wr1_parser_dir', CONTRIBUTION_AUDIT_WR1_PARSER_DIR ),
  );
  $form['globalcollect_audit_wr1_files_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WR1 files' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR ),
  );
  $form['globalcollect_audit_log_files_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WMF GlobalCollect log files' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR ),
  );
  $form['globalcollect_audit_test_mode']  = array(
    '#type' => 'checkbox',
    '#title' => t( 'When this box is checked, no stomp messages will be sent.' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_test_mode', CONTRIBUTION_AUDIT_TEST_MODE ),
  );
  $form['globalcollect_audit_plusminus']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Plus or minus search (in days)' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_plusminus', CONTRIBUTION_AUDIT_PLUSMINUS ),
  );
  return system_settings_form( $form );
}


/**
 * Find Globalcollect transactions not recorded in civicrm_contribution
 */
function globalcollect_audit_find_missing_gc_trxns( $transactions ) {
  $missing_trxns = array();
  
  $dbs = _queue2civicrm_get_dbs();
  $dbs->use_civicrm();

  // check for matching ids - if it doesnt match, it's missing
  echo "Checking for missing transactions\n";
  foreach ( array_keys( $transactions ) as $order_id ) {
    $query = "SELECT {trxn_id} FROM civicrm_contribution WHERE trxn_id LIKE 'GLOBALCOLLECT %s' OR trxn_id LIKE 'RECURRING GLOBALCOLLECT %s'";
    $result = db_query( $query, $order_id . "%", $order_id . "%" );
    if ( !$result->num_rows ) {
	  echo "!";
      $missing_trxns[$order_id]  = $transactions[$order_id];
      watchdog( 'globalcollect_audit', 'Missing Globalcollect: @tx_id @pm, @pc', array( 
        "@tx_id" => $order_id,
        "@pm" => $transactions[$order_id]['Payment-method'],
        "@pc" => $transactions[$order_id]['Payment-currency'] ), WATCHDOG_DEBUG );  
    } else {
	  echo ".";
      watchdog( 'globalcollect_audit', 'Found Payflow: @id', array( '@id' => $order_id ), WATCHDOG_DEBUG );
    } 
  }
  echo "\n";

  $dbs->use_default();
  
  echo count( $missing_trxns ) . " missing records from a possible " . count( $transactions ) . " total records found.\n";
  return $missing_trxns;
}

/**
 * So, that happened. My bad. 
 * I'm keeping this function around, because it can currently (in only one way, 
 * but we may need to expand on this in the future) to track fuckups.
 * Not used anywhere. 
 */
function globalcollect_audit_track_fuckup(){
	$directory = '/home/khorn/recurring_extra/';
	$csv = $directory . 'recurring.csv';
	$testme = file($csv, FILE_SKIP_EMPTY_LINES);
	$ids = array();
	foreach( $testme as $line ){
		$temp = explode(',', $line);
		$ids[$temp[0]][] = $temp[1];
	}
	echo print_r($ids, true);
	
	
	$processed_id_count = 0;
	$processed_days_count = 0;
	$found_ids_count = 0;
	$recurring_count = 0;
	$not_recurring_count = 0;
	$unfound = array();
	$fuckups = array();
	
	
	foreach ( $ids as $date => $id_array ){
		$logname = $directory . $date . '_iop.log';
		$logname2 = $directory . globalcollect_audit_add_to_date( $date, 1 ) . '_iop.log';
		foreach ( $id_array as $grepforme ){
			echo ".";
			$processed_id_count += 1;
			$cmd = "grep <ORDERID>" . trim($grepforme) . "</ORDERID> $logname";

			$ret = array();
			exec( escapeshellcmd($cmd), $ret, $errorlevel );
			//echo $cmd . "\n";
			
			if ( !count( $ret ) ){
				$cmd = "grep <ORDERID>" . trim($grepforme) . "</ORDERID> $logname2";

				$ret = array();
				exec( escapeshellcmd($cmd), $ret, $errorlevel );
			}
	
			if ( count( $ret ) > 0 ){
				$found_ids_count += 1;
				if ( strstr( $ret[0], "<ORDERTYPE>4" ) ){
					$recurring_count += 1;
				} else {
					$not_recurring_count += 1;
				}
			} else {
				$unfound[$date][] = trim($grepforme);
			}
		}
		
	}
	
	echo "Processed $processed_id_count \n";
	echo "Found $found_ids_count \n";
	echo "Unfound ids: " . print_r( $unfound, true ) . "\n";
	echo "Recurring Count $recurring_count \n";
	echo "Not Recurring Count $not_recurring_count \n";
	die();
	
}


function globalcollect_audit_parse_all_wr1(){
	$actual_start_time = microtime(true);
	
	//look at the wr1 files dir, and load in everything that's a "*.wr?". 
	//and by that I mean, fire off the parser at everything that's in that format. 
	$parser_directory = variable_get( 'globalcollect_audit_wr1_parser_dir', CONTRIBUTION_AUDIT_WR1_PARSER_DIR );
	$files_directory = variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR );
	$test_mode = variable_get( 'globalcollect_audit_test_mode', CONTRIBUTION_AUDIT_TEST_MODE );
	$run_all_wr1 = variable_get( 'globalcollect_audit_run_all_wr1', false );
	require_once( $parser_directory . 'Wr1DataRecord.php' );
	
	$wr1_files = globalcollect_audit_get_all_wr1_files();
	$missing = array();
	
	$errorful_transactions = array();
	
	while ( ( $run_all_wr1 || !count( $missing ) ) && count( $wr1_files ) ){
		$local_missing = array();
		$wr1_data = array();
		$file = array_shift( $wr1_files );
		echo "Parsing $file\n";
		
		$wr1_parser = new Wr1DataFileParser( $file );
		$local_start_time = microtime(true);
		foreach( $wr1_parser->getRecordIterator() as $record ) {
			switch ( $record['Payment-method'] ){
				case 'CC':
					$wr1_data[$record['Order-number']]  = $record;
					echo 'c';
					break;
				case 'BA':
				case 'OB':
					$wr1_data[$record['Additional-reference']]  = $record;
					echo 'b';
					break;
				default:
					$message = "Payment method '" . $record['Payment-method'] . "' not recognized. Please rectify in " . __FUNCTION__ .  print_r( $record, true );
					globalcollect_audit_log_error( $message, "WR1_PAYMENT_METHOD" );
					return;
			}
		} 
		echo "\n";
		$time = microtime(true) - $local_start_time;
		echo "$file parsed in $time\n";
		if ( count( $wr1_data ) ){
			$local_missing = globalcollect_audit_find_missing_gc_trxns( $wr1_data );
			$missing = array_merge( $missing, $local_missing );
		}
		
		if ( !count( $local_missing ) ){
			globalcollect_audit_move_completed_wr1( $file );
		} 
	}
	
	if ( !count($missing) ){
		echo "No missing transactions found. Done!\n";
		return;
	}
	
	$counts = array();
	
	while ( count( $missing ) && globalcollect_audit_can_continue() ) {
		$local_found_ids = array();
		$log = globalcollect_audit_get_next_log( $missing, $counts );
		if ( is_null( $log ) ){
			continue;
		}

		echo "Trying log $log\n";
		$tried_count = 0;
		foreach ( $missing as $order_id => $data ){
			++$tried_count;
			$date = globalcollect_audit_get_wr1_date( $data );
			if ( is_null($date) ){
				echo "X";
				continue;
			}
			$logdata = globalcollect_audit_get_log_data_by_order_id( $order_id, $log );
			if ( is_null( $logdata ) ){
				echo "X";
				continue;
			}
			if ($logdata === false){
				echo ".";
				continue;
			}

			//This isn't going to work unless you're connecting to a database that has the row you're looking for. 
			$missing_txn_message = globalcollect_audit_format_data_for_stomp( $data, $logdata['donor_data'], $logdata['contribution_id'] );
			if ( is_null( $missing_txn_message ) ){
				//log this out in a list of troubled transactions. 
				$info = array(
					'contribution_id' => $logdata['contribution_id'],
					'log' => $log,
					'data' => $data,
					'logdata' => $logdata,
				);
				$errorful_transactions[] = $info;
				echo "X";
				continue;
			}

			if ( $test_mode ){
				$local_found_ids[] = $order_id;
				echo "!";
			} else {
				if ( sendStomp( $missing_txn_message ) ){
					watchdog('globalcollect_audit', __FUNCTION__ . ': Message sent to stomp successfully: ' . print_r( $missing_txn_message, true ), array(), WATCHDOG_INFO);
					$local_found_ids[] = $order_id;
					echo "!";
				} else {
					$wd_message = __FUNCTION__ . ': Sending message to stomp failed: ' . print_r( $missing_txn_message, true );
					$drush_message = "Failed sending STOMP message to queue.";
					globalcollect_audit_log_error( $wd_message, "STOMP_BAD_SEND", $drush_message );
					return;
				}
			}

		}
		echo "\n";
		
		//TODO: Output some pretty stats here. 
		$logdate = globalcollect_audit_get_log_date_by_file($log);
		$counts[$logdate] = count( $local_found_ids );
		echo $counts[$logdate] . " records found in $log\n";
		
		//now, we unset the array keys we found, so as not to corrupt the foreach we were in.
		foreach ($local_found_ids as $id) {
			unset($missing[$id]);
		}
		
	}
	//And loop. 
		
	//if we're running in make_missing mode (explicit param required), do that.
	$make_missing = variable_get( 'globalcollect_audit_make_missing', false );
	if ( $make_missing && count( $missing ) ){
		//make all the remaining missing transactions with data defaults. 
		foreach ( $missing as $missing_txn ) {
			$missing_txn_message = globalcollect_audit_format_data_for_stomp( $data );
		}
	}
	
	if ( count( $errorful_transactions ) ){
		echo "Errorful Transactions: " . print_r( $errorful_transactions, true );
	}
	echo "Transactions found by log:" . print_r( $counts, true );
	echo "Still Missing: " . count($missing) . ".";
	if ( count($missing) ){
		echo " Good luck with that.";
	}	
	echo "\n";
	
	$time = microtime(true) - $actual_start_time;
	echo "Total Runtime: $time\n";
}


function globalcollect_audit_format_data_for_stomp( $wr1, $donor_data = null, $contribution_tracking_id = null ){
	$fake_db = variable_get( 'globalcollect_audit_fake_db', CONTRIBUTION_AUDIT_FAKE_DB );
	$make_missing = variable_get( 'globalcollect_audit_make_missing', false );
	//you should probably make sure the data between the two sources match up before we do anything else
	$unstaged_amount = 0;
	
	if ( is_null( $donor_data ) && $make_missing ) {
		$donor_data = globalcollect_audit_make_default_donor_data( $wr1 );
	}
	
	//if we have $donor_data, make sure it's rational
	if ( (int)$wr1['Payment-amount'] !== (int)$donor_data['AMOUNT']  ){
		$amount_problem = true;
		if ( array_key_exists( 'Over-under-amount-local', $wr1 ) && (int)$wr1['Over-under-amount-local'] > 0 ){
			//then the mismatch is expected, and with a little more checking...
			// Invoice-amount-deliv = what we think it is.
			// Payment-amount = what actually happened.
			if ( (int)$wr1['Invoice-amount-deliv'] === (int)$donor_data['AMOUNT']  ){
				$unstaged_amount = (int)$wr1['Payment-amount']/100; //it's a GC thing.
				$amount_problem = false;
			}
		} 
		if ( $amount_problem ) {
			$message = __FUNCTION__ . " $contribution_tracking_id Payment amount mismatch! Aborting.";
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			return null;
		}
	} else {
		$unstaged_amount = (int)$wr1['Payment-amount']/100; //it's a GC thing.
	}
	
	if ( !array_key_exists( 'Transaction-currency', $wr1 ) ){
		$wr1['Transaction-currency'] = $wr1['Payment-currency'];
	}
	
	if ( $wr1['Transaction-currency'] !== $donor_data['CURRENCYCODE']  ){
		$message = __FUNCTION__ . " $contribution_tracking_id Currency code mismatch! Aborting. ";
		globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
		return null;
	}
	
	$recurring = false;
	if ( array_key_exists( 'ORDERTYPE', $donor_data ) && $donor_data['ORDERTYPE'] == '4' ){
		$recurring = true;
	}
	
	//getting the payment type according to us. Sneaky.
	if ( $make_missing ){
		$contribution_tracking = globalcollect_audit_make_contribution_tracking_data( $wr1 );
	} else {
		if ( !$fake_db ) {
			$contribution_tracking = globalcollect_audit_get_contribution_tracking_data( $contribution_tracking_id );
		} else {
			$contribution_tracking = globalcollect_audit_get_contribution_tracking_data( 1 );
		}
		if ( $contribution_tracking ){
			$payment_method_utm = explode( '.', $contribution_tracking['utm_source'] );
			$payment_method_utm = $payment_method_utm[2];

			$idiotic_date_format = $contribution_tracking['ts'];
			$real_timestamp = date_parse( $idiotic_date_format );

			$contribution_tracking['ts'] = mktime( 
				$real_timestamp['hour'], 
				$real_timestamp['minute'], 
				$real_timestamp['second'], 
				$real_timestamp['month'], 
				$real_timestamp['day'], 
				$real_timestamp['year']
			);
			//echo " $idiotic_date_format = $real_timestamp \n";

		} else {
			$payment_method_utm = null;
		}
	}

	$payment_submethod = false;
	if ( !$make_missing && array_key_exists( 'PAYMENTPRODUCTID', $donor_data ) ){
		$payment_info = globalcollect_audit_get_payment_submethod($donor_data['PAYMENTPRODUCTID']);
		$payment_method = $payment_info['group'];
		$payment_submethod = $payment_info['code'];
		if ( !$fake_db && $payment_method != $payment_method_utm ){
			$message = __FUNCTION__ . " Payment Method Mismatch on $contribution_tracking_id. UTM indicates '$payment_method_utm', but xml was sent for '$payment_method'. Using xml value.";
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			//this is not fatal, so don't return here. 
		}
	}
	
	if ( $make_missing ){
		$payment_info = globalcollect_audit_make_payment_method_info( $wr1 );
		if ( array_key_exists( 'payment_method', $payment_info ) ){
			$payment_method = $payment_info['payment_method'];
		} else {
			$message = __FUNCTION__ . " Making missing records: Failed to find a payment method for " . $wr1['Payment-method'];
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			return null;
		}
		if ( array_key_exists( 'payment_submethod', $payment_info ) ){
			$payment_submethod = $payment_info['payment_submethod'];
		}
	}
	
	//start it off with the stuff that's always there...
	$stomp_data = array(
		'contribution_tracking_id' => $contribution_tracking_id,
		'gateway' => 'globalcollect',
		'amount' => $unstaged_amount,
		'payment_method' => $payment_method,
	);
	
	if ( $payment_submethod ){
		$stomp_data['payment_submethod'] = $payment_submethod;
	}
	
	if( $recurring ){
		$stomp_data['recurring'] = 1;
	}
	
	if ( $make_missing ){
		$stomp_data['audit_hole'] = true;
	}
	
	
	//now, we have three sources for this mess: $wr1, $donor_data, and $contribution_tracking. Map 'em.
	$stomp_field_map = array(
		'optout' => array( 'contribution_tracking', 'optout' ),
		'anonymous' => array( 'contribution_tracking', 'anonymous' ),
		'comment' => array( 'contribution_tracking', 'note' ), //I think.
		'size',
		'premium_language',
		'utm_source' => array( 'contribution_tracking', 'utm_source' ),
		'utm_medium' => array( 'contribution_tracking', 'utm_medium' ),
		'utm_campaign' => array( 'contribution_tracking', 'utm_campaign' ),
		'language' => array( 'contribution_tracking', 'language' ), //probably the best one to use. 
		'referrer' => array( 'contribution_tracking', 'referrer' ),
		'email' => array( 'donor_data', 'EMAIL' ),
		'fname' => array( 'donor_data', 'FIRSTNAME' ),
		'mname',
		'lname' => array( 'donor_data', 'SURNAME' ),
		'street' => array( 'donor_data', 'STREET' ),
		'city' => array( 'donor_data', 'CITY' ),
		'state' => array( 'donor_data', 'STATE' ),
		'country' => array( 'donor_data', 'COUNTRYCODE' ),
		'zip' => array( 'donor_data', 'ZIP' ),
		'fname2' => array( 'donor_data', 'FIRSTNAME' ),
		'lname2' => array( 'donor_data', 'SURNAME' ),
		'street2' => array( 'donor_data', 'STREET' ),
		'city2' => array( 'donor_data', 'CITY' ),
		'state2' => array( 'donor_data', 'STATE' ),
		'country2' => array( 'donor_data', 'COUNTRYCODE' ),
		'zip2' => array( 'donor_data', 'ZIP' ),
		'gateway_txn_id' => array( 'donor_data', 'ORDERID' ),
		'response', //? Maybe some dummy value for "found it in the audit phase"
		'currency_code' => array( 'donor_data', 'CURRENCYCODE' ),
		'date' => array( 'contribution_tracking', 'ts' ), //double-check how the dates work
	);
	
	foreach ( $stomp_field_map as $key => $location ){
		if( is_array( $location ) ){
			$source = $location[0];
			$source_key = $location[1];
			if ( is_array( ${$source} ) && array_key_exists( $source_key, ${$source} ) ){
				$stomp_data[$key] = ${$source}[$source_key];
			} else {
				$stomp_data[$key] = '';
			}
		} else {
			$stomp_data[$location] = '';
		}
	}
	
	return $stomp_data;


}

function globalcollect_audit_make_default_donor_data( $wr1 ){
	
	$donor_data = array(
		'AMOUNT' => (int)$wr1['Payment-amount'],
		'CURRENCYCODE' => $wr1['Transaction-currency'],
		'EMAIL' => 'nobody@wikimedia.org', //this guy gets around.
		'FIRSTNAME' => 'Audit',
		'SURNAME' => 'Donor',
		'STREET' => '123 Fake Street',
		'CITY' => 'Springfield',
		'ORDERID' => 'Order-number'
	);
	
//	In the future: Deal with recurring by doing this, on recurring txn's
//	$donor_data['ORDERTYPE'] = '4'
	
	return $donor_data();
}

function globalcollect_audit_make_contribution_tracking_data( $wr1 ){
	
//			$payment_method_utm = explode( '.', $contribution_tracking['utm_source'] );
//			$payment_method_utm = $payment_method_utm[2];
//
//			$idiotic_date_format = $contribution_tracking['ts'];
//			$real_timestamp = date_parse( $idiotic_date_format );
//
//			$contribution_tracking['ts'] = mktime( 
//				$real_timestamp['hour'], 
//				$real_timestamp['minute'], 
//				$real_timestamp['second'], 
//				$real_timestamp['month'], 
//				$real_timestamp['day'], 
//				$real_timestamp['year']
//			);
//			//echo " $idiotic_date_format = $real_timestamp \n";
			
			
}

function globalcollect_audit_make_payment_method_info( $wr1 ){
	if ( $wr1['Payment-method'] === 'CC' ){
		//[Creditcard-company] = 'ECMC'
		//Gee, it would be swell if they had an index of these things so I could map them
		return array( 'payment_method' => 'cc' );
	}
}


function globalcollect_audit_get_contribution_tracking_data( $contribution_tracking_id ){ 
	$dbs = _queue2civicrm_get_dbs();
	$dbs->use_default();

	$query = "SELECT * FROM contribution_tracking WHERE id = %d";
	$result = db_query( $query, $contribution_tracking_id );
	if ( !$result->num_rows ) {
		watchdog( 'globalcollect_audit', 'Missing Contribution Tracking data: @id ', array( 
		"@id" => $contribution_tracking_id ), WATCHDOG_DEBUG );  
	} else {
		watchdog( 'globalcollect_audit', 'Found Contribution: @id', array( '@id' => $contribution_tracking_id ), WATCHDOG_DEBUG );
	} 
	
	$result = db_fetch_array( $result );
	
	return $result;
}



function globalcollect_audit_get_all_wr1_files(){
	$files_directory = variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR );
	//foreach file in the directory, if it's a '*.wr?', add it to the list of files we could open.
	$files = array();
	if ( $handle = opendir( $files_directory ) ){
		while ( ( $file = readdir( $handle ) ) !== false ){
			if ( strpos( $file, '.wr' ) ){ //these can also be '.wr2', '.wr3', etc. 
				$files[] = $files_directory . $file;
			}
		}
	}
	closedir($handle);
	
	//This simple sort will work on the GC file naming convention until the year 
	//2020, when January will come up before anything else in the previous year. 
	//By that time, they will hopefully have changed their dumb 8-char filename 
	//standard anyway. 
	sort($files); 
	
	return $files;
	

	
}

function globalcollect_audit_move_completed_wr1( $file ){
	$subdir = 'completed';
	$files_directory = variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR );
	$completed_dir = $files_directory . '/' . $subdir;
	if ( !is_dir( $completed_dir ) ){
		if ( !mkdir ( $completed_dir, 0700 )){
			$message = "Could not make $completed_dir";
			watchdog('globalcollect_audit', $message);
			return false;
		}	
	}
	
	$path_info = pathinfo( $file );
	$newfile = $path_info['dirname'] . '/' . $subdir . '/' . $path_info['basename'];
	
	if (!rename( $file, $newfile )){
		$message = "Unable to move $file to $newfile";
		watchdog('globalcollect_audit', $message);
		return false;
	}
	echo "Moved $file to $newfile\n";
	return true;
}

function globalcollect_audit_get_wr1_date( $data ){
	$date = '';
	switch ( $data['Payment-method'] ){
		case 'CC':
			$date = $data['Date-authorised'];
			break;
		case 'BA': //Bank Payment
		case 'OB': //Real-time Bank
			$date = $data['Date-due'];
			break;
		default:
			$message = __FUNCTION__ . "No recognized date field. for payment method " . $data['Payment-method'] . ". Please rectify in " . __FUNCTION__ .  print_r( $data, true );
			globalcollect_audit_log_error( $message, "WR1_DATE" );
			return null;
	}
	return $date;
}

function globalcollect_audit_get_next_log( $missing, $counts ){
	static $tried = array();
	$plusminus = variable_get( 'globalcollect_audit_plusminus', CONTRIBUTION_AUDIT_PLUSMINUS );
	
	$tryme = false;
	
	if ( count( $counts ) ){
		arsort( $counts );
		$zerocounter = 0;
		//step back to plusminus and see if they've all been tried. 
		foreach ( $counts as $date => $hits ){
			if ( $hits > 0 ){
				for ( $i = 1; $i <= $plusminus && !$tryme; ++$i ){
					$check_date = globalcollect_audit_add_to_date( $date, -1*$i );
					if ( !array_key_exists( $check_date, $counts ) ){
						$tryme = $check_date;
					}
				}
			} 
			if ( $tryme ){
				break;
			}
		}
	}
	
	if ( !$tryme ){
		$dates = array();
		foreach ( $missing as $transaction ){
			$date = globalcollect_audit_get_wr1_date( $transaction );
			if (is_null($date)){
				return null;
			}
			if ( array_key_exists( $date, $dates ) ){
				$dates[$date] += 1;
			} else {
				$dates[$date] = 1;
			}
		}

		//now turn the array inside out and sort it by most popular date
		array_flip($dates);
		arsort($dates);
		//echo print_r($dates);

		foreach ( $dates as $date => $count ){
			if ( !in_array($date, $tried) ){
				$tryme = $date;
				break;
			}
		}
	}
	
	if ( !$tryme ){
		//we've tried all the log dates explicitly present in the wr1. Now try more.
		$more_tries = array();
		for($i=1; $i < ($plusminus + 1); ++$i ){
			$more_tries[] = $i;
			$more_tries[] = $i * -1;
		}
		
		foreach ( $dates as $date => $count ){
			foreach( $more_tries as $add ){
				$newdate = globalcollect_audit_add_to_date( $date, $add );
				if ( !in_array($newdate, $tried) ){
					$tryme = $newdate;
					break 2;
				}
			}
		}
	}
	
	
	if ( !$tryme ){
		$message = __FUNCTION__  . " No 'next' log identified. Dates checked: " . print_r( $tried, true ) . "\nCurrent Missing: " . print_r( $dates, true ) . "\n";
		globalcollect_audit_log_error( $message, "WR1_LOG_FATAL" );
		return null;
	}
	
	$tried[] = $tryme;
	return globalcollect_audit_get_log_file_by_date( $tryme );
	
}


function globalcollect_audit_get_log_file_by_date( $date ){
	//I know somebody is going to try to come back in time just to punch me for this one, but...
	$date = globalcollect_audit_add_to_date( $date, 1 );
	//I swear it makes sense. Most of the data in any given log are actually from the previous day. 
	
	$log_directory = variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR );
	$file = $log_directory . $date . '_iop.log';
	if ( file_exists( $file ) ){
		return $file;
	} else {
		//try to make it.
		$original_file = $log_directory . 'globalcollect_' . $date . '.log';
		if ( file_exists( $original_file ) ){
		
			$cmd = escapeshellcmd("grep 'INSERT_ORDERWITHPAYMENT' $original_file") . " > " . escapeshellcmd($file);

			echo $cmd . "\n";
			$ret = array();
			exec( $cmd, $ret, $errorlevel );
			
			if ( file_exists( $file ) ) {
				return $file;
			} else {
				$message = __FUNCTION__ . " $file could not be created. Something went wrong with the grep (permissions?)";
				globalcollect_audit_log_error( $message, "WR1_LOG_FATAL" );
				return null;
			}
			
		} else {
			$message = __FUNCTION__ . " $original_file not found. Please copy that file to the specified directory and re-run.";
			globalcollect_audit_log_error( $message, "WR1_LOG" );
			return null;
		}
	}
	
}


function globalcollect_audit_get_log_date_by_file( $file ){
	$log_directory = variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR );
	$date = str_replace( $log_directory, '', $file);
	$date = substr( $date, 0, strpos( $date, '_' ) );
	if ( !is_numeric( $date ) ){
		die( __FUNCTION__ . " is faulty. $file's date is not $date" );
	}
	$date = globalcollect_audit_add_to_date( $date, -1 );
	return $date;
}

function globalcollect_audit_add_to_date( $date, $add ){
	$date = date_create( $date );
	date_add($date, date_interval_create_from_date_string("$add days"));
	
	return date_format($date, 'Ymd');
}


function globalcollect_audit_get_log_data_by_order_id( $order_id, $log ){
	
	$cmd = "grep <ORDERID>$order_id</ORDERID> $log";

	//echo $cmd . "\n";
	$ret = array();
	exec( escapeshellcmd($cmd), $ret, $errorlevel );
	
	if ( count( $ret ) > 0 ){
		
		//get the xml, and the contribution_id... and while we're at it, parse the xml. 
		$xml = null;
		$full_xml = false;
		$contribution_id = null;
		foreach ( $ret as $line ){
			if ( is_null( $xml ) ){
				//look for the raw xml. 
				if ( strpos( $line, 'RETURNED FROM CURL' ) ){
					$xmlstart = strpos( $line, '<XML>' );
					//$xmlend = strpos( $line, '</XML>' ) + 6;
					$xmlend = strpos( $line, '</XML>' );
					if ( $xmlend ){
						$full_xml = true;
						$xmlend += 6;
						$xml = substr($line, $xmlstart, $xmlend - $xmlstart);
					} else {
						//this is a broken line, and it won't load... but we can still parse what's left of the thing, the slow way.
						$xml = substr($line, $xmlstart);
					}
				}
			}
			if ( is_null( $contribution_id ) ){
				//get the contribution tracking id. 
				$ctid_end = strpos( $line, 'Raw XML Response' );
				if ( $ctid_end > 0 ){
					$ctid_start = strpos( $line, '_gateway:' ) + 9;
					$ctid = substr($line, $ctid_start, $ctid_end - $ctid_start);
					$contribution_id = trim( $ctid, ' :' );
				}
			}
		}

		if ( is_null( $contribution_id ) || is_null( $xml ) ){
			//TODO: This needs more love. We can't go on without both parts, but we should log that we found some of it.
			echo "OH NOES. Couldn't find enough info in this log! Skipping!" . print_r( $data, true );
			return null;
		} else {
			//go on with your bad self
			//echo "$order_id: '$contribution_id'. XML: \n$xml\n";
			//now parse the xml...
			
			$donor_data = array();
				
			if ( $full_xml ){
				$xmlobj = new DomDocument;
				$xmlobj->loadXML($xml);

				$parent_nodes = array(
					'ORDER',
					'PAYMENT'
				);

				foreach ( $parent_nodes as $parent_node ){
					foreach ( $xmlobj->getElementsByTagName( $parent_node ) as $node ) {
						foreach ( $node->childNodes as $childnode ) {
							if ( trim( $childnode->nodeValue ) != '' ) {
								$donor_data[$childnode->nodeName] = $childnode->nodeValue;
							}
						}
					}
				}
			} else {
				
				$search_for_nodes = array(
					'ORDERID' => true,
					'AMOUNT' => true,
					'CURRENCYCODE' => true,
					'PAYMENTPRODUCTID' => true,
					'ORDERTYPE' => true,
					'EMAIL' => true,
					'FIRSTNAME' => false,
					'SURNAME' => false,
					'STREET' => false,
					'CITY' => false,
					'STATE' => false,
					'COUNTRYCODE' => true,
					'ZIP' => false,
				);
				
				foreach ( $search_for_nodes as $node => $mandatory ){
					$tmp = globalcollect_audit_get_partial_xml_node_value( $node, $xml );
					if ( !is_null( $tmp ) ){
						$donor_data[$node] = $tmp;
					} else {
						if ( $mandatory ){
							$wd_message = __FUNCTION__ . ": Mandatory field $node missing for $contribution_id. Aborting.";
							globalcollect_audit_log_error( $wd_message, 'MISSING_MANDATORY_DATA' );
							return null;
						} else {
							$donor_data[$node] = '';
						}
					}
				}
			}
			
			$return['contribution_id'] = $contribution_id;
			$return['donor_data'] = $donor_data;
			return $return;
		}
	}
	return false;
}

function globalcollect_audit_log_error( $watchdog_message, $drush_code, $drush_message = null ){
	if ( is_null( $drush_message ) ){
		$drush_message = $watchdog_message;
	}
	watchdog('globalcollect_audit', $watchdog_message, WATCHDOG_ERROR);
	drush_set_error($drush_code, $drush_message);
}

function globalcollect_audit_can_continue(){
	//check for drush errors
	$errors = drush_get_error_log();
	if ( count( $errors ) ){
		//nonfatal errors: 
		//"WR1_DATA_FORMAT" 
		$nonfatal = array(
			'WR1_DATA_FORMAT',
			'MISSING_MANDATORY_DATA',
			'WR1_LOG'
		);
		foreach ( $errors as $code => $thing){
			if ( !in_array( $code, $nonfatal) ){
				echo print_r( $errors, true );
				return false;
			}
		}
	}
	return true;
}

function globalcollect_audit_get_partial_xml_node_value( $node, $xml ){
	$node1 = "<$node>";
	$node2 = "</$node>";

	$valstart = strpos( $xml, $node1 ) + strlen( $node1 );
	if ( !$valstart ){
		return null;
	}
	
	$valend = strpos( $xml, $node2 );
	if ( !$valend ){ //it cut off in that node. This next thing is therefore safe(ish). 
		$valend = strpos( $xml, '</' );
	}
	
	if ( !$valend ){
		return null;
	}
	
	$value = substr( $xml, $valstart, $valend - $valstart );
	return $value;

}

function globalcollect_audit_get_payment_submethod( $payment_product ){
	//get the payment product as a number. Then, look it up. 
	$map = array(
		11 => array(
			//GC Bank Transfer (new)
			'code' => 'bt',
			'group' => 'bt',
		),
			//Credit Cards: If the card is specified, land it in the right specific bucket.
			//otherwise: cc
		1 => array(
			'code' => 'visa',
			'group' => 'cc',
		),
		3 => array(
			'code' => 'mc',
			'group' => 'cc',
		),
		2 => array(
			'code' => 'amex',
			'group' => 'cc',
		),
		117 => array(
			'code' => 'maestro',
			'group' => 'cc',
		),
		118 => array(
			'code' => 'solo',
			'group' => 'cc',
		),
		124 => array(
			'code' => 'laser',
			'group' => 'cc',
		),
		125 => array(
			'code' => 'jcb',
			'group' => 'cc',
		),
		128 => array(
			'code' => 'discover',
			'group' => 'cc',
		),
		130 => array(
			'code' => 'cb',
			'group' => 'cc',
		),
		713 => array(
			//Direct Debit - all 'dd'
			'code' => 'dd_at',
			'group' => 'dd',
		),
		716 => array(
			'code' => 'dd_be',
			'group' => 'dd',
		),
		717 => array(
			'code' => 'dd_ch',
			'group' => 'dd',
		),
		712 => array(
			'code' => 'dd_de',
			'group' => 'dd',
		),
		719 => array(
			'code' => 'dd_es',
			'group' => 'dd',
		),
		714 => array(
			'code' => 'dd_fr',
			'group' => 'dd',
		),
		715 => array(
			'code' => 'dd_gb',
			'group' => 'dd',
		),
		718 => array(
			'code' => 'dd_it',
			'group' => 'dd',
		),
		711 => array(
			'code' => 'dd_nl',
			'group' => 'dd',
		),
		840 => array(
			//paypal
			'code' => 'ew_paypal',
			'group' => 'ew',
		),
		841 => array(
			//webmoney
			'code' => 'ew_webmoney',
			'group' => 'ew',
		),
		843 => array(
			//moneybookers
			'code' => 'ew_moneybookers',
			'group' => 'ew',
		),
		845 => array(
			//cashu  :)
			'code' => 'ew_cashu',
			'group' => 'ew',
		),
		500 => array(
			//bpay
			'code' => 'bpay',
			'group' => 'obt',
		),
		805 => array(
			//nordea
			'code' => 'rtbt_nordea_sweden',
			'group' => 'rtbt',
		),
		809 => array(
			//iDeal (exists)
			'code' => 'rtbt_ideal',
			'group' => 'rtbt',
		),
		810 => array(
			//enets
			'code' => 'rtbt_enets',
			'group' => 'rtbt',
		),
		836 => array(
			//sofort (exists!)
			'code' => 'rtbt_sofortuberweisung',
			'group' => 'rtbt',
		),
		856 => array(
			//EPS
			'code' => 'rtbt_eps',
			'group' => 'rtbt',
		),
		1503 => array(
			//Boleto
			'code' => 'cash_boleto',
			'group' => 'cash',
		),
	);
	
	return $map[$payment_product];

}