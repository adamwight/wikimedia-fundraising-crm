<?php
// include common functions
require_once( drupal_get_path( 'module', 'queue2civicrm' ) . '/queue2civicrm_common.inc' );

/**
 * Implementation of hook_menu().
 */
function queue2civicrm_menu() {
  $items = array();
  
  $items['admin/settings/queue2civicrm'] = array(
    'title' => 'Queue to CiviCRM',
    'description' => t('Configure message queue interface.'),
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queue2civicrm_settings'),
  );

  $items['admin/settings/queue2civicrm/configure'] = array(
    'title' => 'Configure',
    'access arguments' => array('administer queue2civicrm'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/settings/queue2civicrm/test'] = array(
    'title' => 'Test',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'queue2civicrm_test',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/settings/queue2civicrm/insert'] = array(
    'title' => 'Insert item',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queue2civicrm_insertmq_form'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  
  $items['queue2civicrm'] = array(
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'page callback' => 'queue2civicrm_batch_process',
  );
  
  return $items;
}

function queue2civicrm_test() {
  require_once variable_get('queue2civicrm_stomp_path', drupal_get_path('module', 'queue2civicrm') . '/Stomp.php');
  $content = array();
  
  $content[] = '<p>Attempting connection to ' . variable_get('queue2civicrm_url', 'tcp://localhost:61613') . '... ';  
  $con = new Stomp(variable_get('queue2civicrm_url', 'tcp://localhost:61613'));
  try {
    $con->connect();
    $content[] = '[SUCCESS]</p>';
  }
  catch (Exception $e) {
    $content[] = '[FAILED]</p>' . "<p>$e</p>";
  }
  
  return implode("\n", $content);
}

/**
 * Implementation of hook_perm().
 */
function queue2civicrm_perm() {
  return array('administer queue2civicrm');
}

/**
 * Callback for menu path "admin/settings/queue2civicrm".
 */
function queue2civicrm_settings() {
  $form = array();

  $form['queue2civicrm_stomp_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Stomp Path'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_stomp_path', drupal_get_path('module', 'queue2civicrm') . '/Stomp.php'),
	'#description' => t('Link: ') . l(t('Current version of the Stomp library'), "http://svn.wikimedia.org/viewvc/wikimedia/vendors/stomp_php/current/"),
  );

  $form['queue2civicrm_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Connection URL'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_url', 'tcp://localhost:61613'),
  );

  $form['queue2civicrm_subscription'] = array(
    '#type' => 'textfield',
    '#title' => t('Subscription path'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_subscription', '/queue/test'),
  );

  $form['queue2civicrm_batch'] = array(
    '#type' => 'select',
    '#title' => t('Cron batch size'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_batch', 0),
    '#options' => array(
      0 => '0 (Disable)',
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
      120 => 120,
      150 => 150,
    ),
  );

  $form['queue2civicrm_failmail'] = array(
    '#type' => 'textfield',
    '#title' => t('Email Notification Address'),
    '#required' => FALSE,
    '#default_value' => variable_get('queue2civicrm_failmail', ''),
  );
  
  $form[ 'queue2civicrm_gateways_to_monitor' ] = array(
    '#type' => 'textfield',
    '#title' => t('Gateways to monitor'),
    '#required' => false,
    '#default_value' => variable_get( 'queue2civicrm_gateways_to_monitor', 'payflowpro, paypal' ),
    '#description' => t( 'A CSV of gateway-strings that you wish to monitor in Ganglia.  The gateway string should match the name of the gateway as defined in the "gateway" field of transaction messages.')
  );
  
  return system_settings_form($form);
}

function queue2civicrm_batch_process() {
  set_time_limit(10);

  $processed = 0;
  
  watchdog('queue2civicrm', 'Attempting to process up to ' . variable_get('queue2civicrm_batch', 0) . ' contribution(s).');

  // Attempt to dequeue items for the batch
  for ($i = 0; $i < variable_get('queue2civicrm_batch', 0); ++$i) {
    $success = queue2civicrm_dequeue();
    if ($success) {
      ++$processed;
    } else {
      break;
    }
  }

	$con = _queue2civicrm_stomp_connection();
	$subscription_queue = variable_get('queue2civicrm_subscription', '/queue/test');
	if (is_object( $con ) && $con->isConnected()){
		$con->unsubscribe($subscription_queue);
		$con->disconnect();
	}

  // allow for other modules to handle their own related batch processing
  $batchprocessed = module_invoke_all( 'queue2civicrm_batch_process');
  $processed += array_sum($batchprocessed);
  
  /**
   * this may some day supercede the process counts handled above...
   * 
   * Note that this might be a little whack.  At least, it feels a little sloppy.
   * The tmax/dmax fields should probably be configurable
   * through the UI rather than hardcoded here. Furthermore, we might consider specifying the names
   * of gateways to keep track of, rather than auto-generate the gateways to keep track of during 
   * queue consumption.  With the latter (current) method, we'll only report to gmetric when there
   * are > 0 msgs consumed from the queue - meaning if there are no msgs for a particular gateway, 
   * that fact will not get reported to gmetric.  But I've hardcoded the dmax param here to be the
   * same as the frequency of queue consumption, so if there are no messages in the queue for
   * a particular gateway, the gateway will report as having consumed 0 messages in ganglia anyway.
   */
  $counter = _queue2civicrm_trxn_counter_get();
  foreach ( $counter->get_trxn_counts() as $gateway => $count ) {
    module_invoke( 'ganglia_reporter', 'send_metric', $gateway . ' donations', $count, 'int8', 'donations', 'both', 5, 300 );
  }
  module_invoke( 'ganglia_reporter', 'send_metric', 'Total donations', $counter->get_count_total(), 'int8', 'donations', 'both', 5, 300 );
  
  if ($processed > 0) {
    watchdog('queue2civicrm', 'Successfully processed ' . $processed . ' contribution(s).');
  }
  else {
    watchdog('queue2civicrm', 'No contributions processed.');
  }
}

/**
 * Remove one item from the queue and process it.
 */
function queue2civicrm_dequeue() {
  $con = _queue2civicrm_stomp_connection();
  $subscription_queue = variable_get('queue2civicrm_subscription', '/queue/test');
  if ($con) {
    $con->subscribe($subscription_queue, array('ack' => 'client'));

    $msg = $con->readFrame();
    
    // Skip processing if no message to process.
    if ($msg !== FALSE) {
      watchdog('queue2civicrm', 'Read frame:<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>');      
      set_time_limit(60);
      try {
		_queue2civicrm_get_new_drush_errors(); //redefine "new" before we move on.
        if (queue2civicrm_import($msg)){
			$con->ack($msg);
		} else {
			/* @fixme: Wow, this error handling is probably a mess. This should shake out more sensibly as:
			 * - tests are written for dequeue fail cases
			 * - we get to the cards that deal more specifically with error emails and database rollback conditions.
			 */
			$top_error = _queue2civicrm_get_top_new_drush_error();
			if ($top_error !== false && array_key_exists('err_code', $top_error)){
				$watchdogMe = $top_error['err_code'] . " : " . $top_error['err_text'];
				$failAck = false;
				switch ($top_error['err_code']){
					case 'CIVI_CONFIG': //missing a necessary civicrm value. Probably the Entity Tag, or Payment Instrument
						$watchdogMe .= "\nHalting Process.";
						watchdog('queue2civicrm', $watchdogMe, array(), WATCHDOG_ERROR);
						queue2civicrm_failmail($top_error, array(), $failAck);
						//in this case, it makes sense to just leave with no ack: It's not the message's fault.
						$con->unsubscribe( $subscription_queue );
						return false;
						break;
					case 'IMPORT_TAG':
						//@fixme: Roll back contrib, and...
					case 'IMPORT_CONTRIB': //Contribution could not be added by the import function, but contact made it.
						//@fixme: Roll back contact, and...
					case 'IMPORT CONTACT': //Contact could not be added by the import function.
						$watchdogMe .= "\nHalting Process.";
						watchdog('queue2civicrm', $watchdogMe, array(), WATCHDOG_ERROR);
						queue2civicrm_failmail($top_error, $msg, $failAck);
						$con->unsubscribe( $subscription_queue );
						return false;
						break;
					case 'CIVI_REQ_FIELD': //message missing a hard requirement
						$failAck = true;
						break;
					default: //apparently we don't know what happened to get us here. Log the heck out of it.
						$watchdogMe .= "\nUNHANDLED ERROR CODE. Please debug and handle it.";
						$failAck = true;
				}
				if ($failAck === true){
					$watchdogMe .= "\nRemoving failed message from the queue: \n" . print_r($msg, true);
					$con->ack($msg);
				}
				queue2civicrm_failmail($top_error, $msg, $failAck);
				watchdog('queue2civicrm', $watchdogMe, array(), WATCHDOG_ERROR);

			} else {
				//Case was not properly dealt with.
				queue2civicrm_failmail(array(), $msg, true);
				watchdog('queue2civicrm', "Message failed to import, but threw no errors! Please debug and handle this failure case.\nRemoving message from the queue: \n" . print_r($msg, true), array(), WATCHDOG_ERROR);
				$con->ack($msg);
			}

		}
		return TRUE;
      }
      catch (Exception $e) {
        watchdog('queue2civicrm', 'Could not process frame from queue.', array(), WATCHDOG_ERROR);
      }  
    }
    else {
      watchdog('queue2civicrm', 'Nothing to process.');
    }
    $con->unsubscribe( $subscription_queue ); 
  }
  return FALSE;
}

/**
 * Process one contribution from the queue to CiviCRM.
 */
function queue2civicrm_import( $msg ) {
  // save the original message for logging
  $msg_orig = $msg;
  
  civicrm_initialize(true);

  $msg = queue2civicrm_verify_and_stage($msg);
  if ($msg == false){
	  return false;
  }

	/**
	* prepare data for logging
	*/
	$log = array(
		'gateway' => $msg[ 'gateway' ],
		'gateway_txn_id' => $msg[ 'gateway_txn_id' ],
		'data' => ( is_array( $msg_orig ) ? json_encode( $msg_orig ) : $msg_orig->body ),
		'timestamp' => time(),
		'verified' => 0,
	);
	$cid = _queue2civicrm_log( $log );
	
  //dsm($contribution);
  watchdog('queue2civicrm', 'Contribution:<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>');  

  // insert the contact information
  $contact = _queue2civicrm_contact_insert( $msg );

  if($contact !== false){
	// Insert the location record
	$location = _queue2civicrm_location_insert( $msg, $contact );

	// Insert the contribution record.
	$contribution = _queue2civicrm_contribution_insert( $msg, $contact );
	if($contribution !== false){

		// Tag contact for review
		$tag = _queue2civicrm_tag_insert( $contact );
		if ($tag === false){
			//@fixme: Roll back any importing we've already done...?
			//@fixme: Include a reasonable transaction id in the error message
			drush_set_error("IMPORT_TAG", "Review tag could not be added to the contact. Please make sure it's defined in your CiviCRM install.");
			//Note: If having the import tag turns out to be extremely important and something we should die over, uncomment the next line.
			//return false;
		}

		// Map the tracking record to the CiviCRM contribution
		// @FIXME what do we do if this returns false?  nothing at the moment...
		_queue2civicrm_update_contribution_tracking( $msg, $contribution );

		// construct an array of useful info to invocations of queue2civicrm_import
		$contribution_info = array(
			'contribution_id' => $contribution['id'],
			'contact_id' => $contact['contact_id'],
			'msg' => $msg,
		);

		// update the log if things went well
		if ( $cid && !array_key_exists('is_error', $contribution)) {
			$log[ 'cid' ] = $cid;
			$log[ 'verified' ] = 1;
			$log[ 'timestamp' ] = time();
			_queue2civicrm_log( $log );
		}

		// Send thank you email, other post-import things
		module_invoke_all( 'queue2civicrm_import', $contribution_info );
		
		// keep count of the transactions
		_queue2civicrm_trxn_counter_add( $msg[ 'gateway' ] );

		return TRUE;
	} else {
		//@fixme: Roll back any importing we've already done.
		//@fixme: Include a reasonable transaction id in the error message
		drush_set_error("IMPORT_CONTRIB", "Contribution could not be added. Aborting import.");
		return false;
	}
  } else {
	  //@fixme: Roll back any importing we've already done.
	  //@fixme: Include a reasonable transaction id in the error message
	  drush_set_error("IMPORT_CONTACT", "Contact could not be added. Aborting import.");
	  return false;
  }
}

/**
 * Make the form to insert a test message into the queue
 */ 
function queue2civicrm_insertmq_form() {
  $message = queue2civicrm_generate_message();

  $form['submit1'] = array(
    '#value' => 'Insert into queue',
    '#type' => 'submit'
  );
  
  $form['queue'] = array(
    '#type' => 'textfield',
    '#title' => 'Queue to submit to',
    '#default_value' => '/queue/test_donations',
    '#required' => TRUE
  );
  
  foreach ( $message as $key => $value ) {
    $form[$key] = array(
      '#type' => 'textfield',
      '#title' => $key,
      '#default_value' => $value
    );
  }

  $form['submit2'] = array(
    '#value' => 'Insert into queue',
    '#type' => 'submit'
  );

  return $form;
}

/** 
 * Implementation of hook_form_submit
 *
 * Submits a test message to the queue
 */
function queue2civicrm_insertmq_form_submit($form, &$form_state) {
  $con = _queue2civicrm_stomp_connection();
  if($con){
	  $result = $con->send( $form_state['values']['queue'], drupal_to_js($form_state['values']), array('persistent' => true));
	  $con->disconnect();
	  if (!$result) {
		watchdog('queue2civicrm','Send to queue failed for this message: <pre>' . check_plain(print_r($form_state['values'], TRUE)) . '</pre>');
		$content = 'Failed to add item to the queue.';
		drupal_set_message($content, 'error');
	  }
	  $content = 'Success adding item to the queue!';
	  watchdog('queue2civicrm','Successfully added the following to the queue: <pre>' . check_plain(print_r($form_state['values'], TRUE)) . '</pre>');
	  drupal_set_message($content);
  }
}

/**
 * Generates random data for queue and donation insertion testing
 */
function queue2civicrm_generate_message() {
  //language codes
  $lang = array('EN','DE','FR');

  $currency_codes = array('USD', 'GBP', 'EUR', 'ILS');
  shuffle($currency_codes);
  $currency = (mt_rand(0,1)) ? 'USD' : $currency_codes[0];
  
  $message = array(
	'contribution_tracking_id' => '',
	'optout'                 => mt_rand(0,1),
	'anonymous'              => mt_rand(0,1),
	'comment'                => mt_rand(),
	'utm_source'             => mt_rand(),
	'utm_medium'             => mt_rand(),
	'utm_campaign'           => mt_rand(),
	'language'               => array_rand($lang),
	'referrer'               => 'http://example.com/'.mt_rand(),
	'email'                  => mt_rand() . '@example.com',
	'first_name'             => mt_rand(),
	'middle_name'            => mt_rand(),
	'last_name'              => mt_rand(),
	'street_address'         => mt_rand(),
	'supplemental_address_1' => '',
	'city'                   => 'San Francisco',
	'state_province'         => 'CA',
	'country'                => 'USA',
	'countryID'              => 'US',
	'postal_code'            => mt_rand(02801,99999),
	'gateway'                => 'insert_test',
	'gateway_txn_id'         => mt_rand(),
	'response'               => mt_rand(),
	'currency'               => $currency,
	'original_currency'      => $currency_codes[0],
	'original_gross'         => mt_rand(0,10000)/100,
	'fee'                    => '0',
	'gross'                  => mt_rand(0,10000)/100,
	'net'                    => mt_rand(0,10000)/100,
	'date'                   => date('r'), //time(),
  );
  return $message;
}

function queue2civicrm_verify_and_stage($msg){
	if ( !is_array( $msg ) ) {
		$msg = json_decode($msg->body, true);
	}

	$required = array(
		'email' => '',
		'gross' => '',
		'original_currency' => '',
		'gateway' => '',
		'gateway_txn_id' => ''
	);

	$failflag = false;
	foreach ($required as $key=>$value){
		if (!isset($msg[$key])){
			watchdog('queue2civicrm', "Required Field '$key' not found in message:" . print_r($msg, true), WATCHDOG_ERROR);
			drush_set_error("CIVI_REQ_FIELD", "Required Field '$key' not found in message:" . print_r($msg, true));
			$failflag = true;
		}
	}
	if ($failflag === true){
			return false;
	}

	if(!array_key_exists('fee', $msg) && !array_key_exists('net', $msg)){
		$msg['fee'] = '0.00';
		$msg['net'] = $msg['gross'];
	} elseif(!array_key_exists('fee', $msg) && array_key_exists('net', $msg)){
		$msg['fee'] = $msg['gross'] - $msg['net'];
	} elseif(array_key_exists('fee', $msg) && !array_key_exists('net', $msg)){
		$msg['net'] = $msg['gross'] - $msg['fee'];
	}

    $msg['anonymous'] = (array_key_exists('anonymous', $msg) && $msg['anonymous'] == true && strtoupper($msg['anonymous']) != "FALSE") ? 1 : 0;
    $msg['optout'] = (array_key_exists('optout', $msg) && $msg['optout'] == true && strtoupper($msg['optout']) != "FALSE") ? 1 : 0;

	//defaults: Keys that aren't actually required, but which will cause some portion of the code to complain
	//if they don't exist (even if they're blank).
	$defaults = array(
		'date' => time(), //defaulting to now. @fixme: if you can think of a better thing to do in the name of historical exchange rates.
		'first_name' => 'Chester',
		'middle_name' => '',
		'last_name' => 'McDefault',
		'street_address' => '',
		'supplemental_address_1' => '',
		'city' => '',
		'country' => '',
		'state_province' => '',
		'postal_code' => '',
		'original_gross' => $msg['gross'],
	);

	$msg = _queue2civicrm_normalize_msg( array_merge($defaults, $msg) );

	// set the correct amount fields/data and do exchange rate conversions.
	$msg = _queue2civicrm_normalize_contrib_amnts( $msg );

	return $msg;
}

function queue2civicrm_failmail($error, $message, $removed){
	$to = variable_get('queue2civicrm_failmail', '');
	if ($to != ''){
		$params['error'] = $error;
		$params['message'] = $message;
		$params['removed'] = $removed;
		drupal_mail('queue2civicrm', 'fail', $to, language_default(), $params);
	} else {
		watchdog('queue2civicrm', 'Failmail recipient address not set up!');
	}
}

function queue2civicrm_mail($key, &$message, $params) {
	$language = $message['language'];
	switch($key) {
		case 'fail':
			if ($params['removed'] === true){
				$message['subject'] = t('queue2civicrm Fail Mail : REMOVAL');
				$message['body'][] = t("A message was removed from ActiveMQ due to the following error(s):");
			} elseif(empty($params['error'])){
				$message['subject'] = t('queue2civicrm Fail Mail : UNKNOWN ERROR');
				$message['body'][] = t("A message failed for reasons unknown, while being processed in queue2civicrm:");
			} else {
				$message['subject'] = t('queue2civicrm Fail Mail');
				$message['body'][] = t("A message generated the following error(s) while being processed in queue2civicrm:");
			}

			if(!empty($params['error'])){
				$message['body'][] = t("Error Code: ") . $params['error']['err_code'];
				$message['body'][] = $params['error']['err_text'];
			}
			if(!empty($params['message'])){
				$message['body'][] = "---" . t("Message") . "---";
				$message['body'][] = print_r($params['message'], true);
				$message['body'][] = "---" . t("End") . "---";
			} else {
				$message['body'][] = t("The exact message was deemed irrelevant.");
			}
			break;
	}
}