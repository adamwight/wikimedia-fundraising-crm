<?php

require_once 'db_switcher.inc';
require_once 'recurring.inc';
require_once 'tracking.inc';
require_once 'errors.inc';

/**
 * return a map of option value (id) => option name
 */
function civicrm_api_option_group($group_name, $key = null)
{
	static $cached_group = array();
	if (!array_key_exists($group_name, $cached_group))
	{
		$api = civicrm_api_classapi();
		$api->OptionValue->Get(array(
			'option_group_name' => $group_name,
		));
		$cached_group[$group_name] = array();
		$option_values = $api->values();
		foreach ($option_values as $row)
		{
			$cached_group[$group_name][$row->value] = $row->name;
		}
	}
	if ($key)
	{
		// In this case, just lookup name and return the option value
		$forwards = array_flip($cached_group[$group_name]);
		return $forwards[$key];
	}
	return $cached_group[$group_name];
}

function civicrm_api_contribution_status($key = null)
{
	return civicrm_api_option_group('contribution_status', $key);
}

function civicrm_api_classapi()
{
	civicrm_initialize();
	if (module_load_include('php', 'civicrm', '../api/class.api') === FALSE)
	{
		watchdog('civicrm_api', t('Failed to load civicrm api classes'), array(), WATCHDOG_ERROR);
	}
	else
	{
		return new civicrm_api3();
	}
}

/**
 * Determines the settlement currency for a given donation.
 * Argument is a queue message or a civicrm contribution array.
 */
function wmf_civicrm_get_settlement_currency($transaction)
{
	return 'USD';
}

function wmf_civicrm_settle($contribution, $settled_timestamp)
{
	civicrm_initialize();

	require_once 'CRM/Core/BAO/CustomValueTable.php';
	static $custom_field_key = array();
	if (empty($custom_field_key))
	{
		require_once 'CRM/Core/BAO/CustomField.php';
		foreach (array('total_usd', 'settlement_date') as $name)
		{
			$id = CRM_Core_BAO_CustomField::getCustomFieldID($name, 'contribution_extra');
			$custom_field_key[$name] = "custom_{$id}";
		}
	}

	list($original_currency, $original_amount) = explode(" ", $contribution['source']);
	$total_usd = round(exchange_rate_convert($original_currency, $original_amount, $settled_timestamp), 2);
	$settlement_date = date( 'YmdHis', $settled_timestamp );

	$params = array(
		'entityID' => $contribution['id'],
		$custom_field_key['total_usd'] => $total_usd,
		$custom_field_key['settlement_date'] => $settlement_date,
	);
	$result = CRM_Core_BAO_CustomValueTable::setValues($params);
	if (!empty($result['is_error']))
	{
		watchdog('wmf_civicrm', 'Failed to settle contribution %id: %err', array("%id" => $contribution['id'], "%err" => $result['error_message']), WATCHDOG_ERROR);
	}
}

/**
 * Try to import a transaction message into CiviCRM, otherwise
 * throw an exception.
 */
function wmf_civicrm_contribution_message_import($msg)
{
    $msg = wmf_civicrm_verify_message_and_stage($msg);

    //XXX should be debug level, or does this have a magic purpose?
    watchdog('queue2civicrm', 'Contribution:<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>');

    // insert the contact information
    $contact = wmf_civicrm_message_contact_insert( $msg );

    // Insert the location record
    $location = wmf_civicrm_message_location_insert( $msg, $contact );

    // Insert the contribution record.
    $contribution = wmf_civicrm_message_contribution_insert( $msg, $contact );

    if ( isset( $msg[ 'recurring' ] ) && $msg[ 'recurring' ] == 1 ) {
        watchdog( 'queue2civicrm_import', 'Attempting to insert recurring record.'); //BLAH
        wmf_civicrm_message_contribution_recur_insert( $msg, $contact['id'], $contribution );
    }

    // Tag contact for review
    try {
        $tag = wmf_civicrm_tag_contact_for_review( $contact );
    } catch (WmfException $ex) {
        // XXX copying old logic, continues without a review tag
    }

    // Map the tracking record to the CiviCRM contribution
    // @FIXME what do we do if this returns false?  nothing at the moment...
    wmf_civicrm_message_update_contribution_tracking( $msg, $contribution );

    return $contribution;
}

/**
 * Insert the contribution record
 * 
 * Serves as a standard way for message processors to handle contribution
 * insertion.
 * 
 * @param array $msg
 * @param array $contact
 * @param integer $recur_id   See `civicrm_contribution`.`contribution_recur_id`
 * @param integer $effort_id  The effort id - the number of successful payments for recurring payments
 * @return array
 */
function wmf_civicrm_message_contribution_insert( $msg, $contact, $recur_id=NULL, $effort_id=NULL )
{
    civicrm_initialize();

    //TODO: After we upgrade civi, refactor this whole thing so the data staging 
    //is all done in... y'know: The staging function, which should itself get 
    //moved into common for its universal usefulness. 
    //And another thing: There should be a set/get style pair of functions for 
    //parsing our stupid transaction IDs at this point, because: Yeesh. 
    
    $parts = explode( ' ', $msg['gateway_txn_id'] );
    
    $transaction_id = '';
    $timestamp = '';
    
    switch ( count( $parts ) ){
        case 0:
            throw new WmfException("IMPORT_CONTRIB", "Contribution could not be added. Aborting import.", $msg);
        case 1: 
            //unusual, but let's just assume it's a lonely transaction id and assign a timestamp.
            $transaction_id = $parts[0];
            $timestamp = time();
            break;
        case 2: 
            //regular old style: Transaction ID followed by a timestamp. 
            //we can be reasonably sure this was just generated. 
            $transaction_id = $parts[0];
            $timestamp = $parts[1];
            break;
        case 4:
            //the only way we have four parts in one of these things would be if...
            if (array_shift($parts) != 'RECURRING'){
                throw new WmfException("IMPORT_CONTRIB", 'Cannot add contribution: Malformed gateway_txn_id (4 parts, does not start with "RECURRING")', $msg);
            }
            //and now we're down to three. DO NOT BREAK HERE, OR REORDER THE CASE BLOCKS. 
        case 3:
            //this is either coming in from somewhere totally old and stale, or it's coming in from a GC Recurring subscription
            //Pull out the parts and regen the timestamp.
            $part1 = array_shift($parts);
            
            if ( $part1 == 'RECURRING' ){
                //we have a subscription. 
                if ( array_shift( $parts ) != strtoupper( $msg['gateway']) ){
                    throw new WmfException("IMPORT_CONTRIB", 'Cannot add contribution: Malformed gateway_txn_id (3 parts, recurring, second part is not ucase gateway):', $msg);
                }
            } elseif ( $part1 != strtoupper( $msg['gateway']) ) {
                throw new WmfException("IMPORT_CONTRIB", 'Cannot add contribution: Malformed gateway_txn_id (3 parts, does not start with ucase gateway):', $msg);
            }
            
            $transaction_id = $parts[0];
            $timestamp = time();

            break;
        default: 				
            //error state. Way too many dataz. 
            throw new WmfException("IMPORT_CONTRIB", 'Cannot add contribution: Malformed gateway_txn_id (too many parts):', $msg);
    }
    
    //one last typey-checky thing before we just assume we're all good.
    if ( !is_numeric( $timestamp ) ){
        throw new WmfException("IMPORT_CONTRIB", 'Cannot add contribution: Malformed gateway_txn_id (timestamp does not appear to be numeric):', $msg);
    }
    
    //kill off any pre-existing effort ID in the transaction id. Leaving it as 
    //an explode, though, because we might need to error check on that second 
    //part later. (It should, for instance, be <= the passed-in $effort_id...) 
    $transaction_id = explode( '-', $transaction_id );
    $transaction_id = $transaction_id[0];
    
    if (!is_null($effort_id)){
        $transaction_id .= '-' . $effort_id;
    }
    
    $prefix = $msg['gateway'];

    if ( $recur_id || ( array_key_exists( "recurring", $msg ) && $msg['recurring'] ) ) {
        $prefix = 'RECURRING ' . $prefix;
    }
    
    $trxn_id = strtoupper( $prefix . ' ' . $transaction_id . ' ' . $timestamp );
    
    // Insert the contribution record
    $contribution_type_id = wmf_civicrm_get_civi_id( 'contribution_type_id', 'cash' );

    //XXX always redundant?
    if ( !array_key_exists( "payment_instrument", $msg ) ){
        $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument( $msg );
    }
    $payment_instrument_id = wmf_civicrm_get_civi_id( 'payment_instrument_id', $msg['payment_instrument'] );

    if ( !array_key_exists( 'check_number', $msg ) ){
        $msg['check_number'] = NULL;
    }
    if ( !array_key_exists( 'letter_code', $msg ) ){
        $msg['letter_code'] = NULL;
    }

    $contribution = array(
        'contact_id' => $contact[ 'id' ],
        'total_amount' => $msg['gross'],
        'contribution_type_id' => $contribution_type_id,
        'payment_instrument_id' => $payment_instrument_id,
        'fee_amount' => $msg['fee'],
        'net_amount' => $msg['net'],
        'trxn_id' => $trxn_id,
        'receive_date' => date( 'Y-m-d H:i:s', $msg['date'] ),
        'currency' => $msg['currency'],
        'source' => $msg['original_currency'] . ' ' . $msg['original_gross'],
        'contribution_recur_id' => $recur_id,
        'check_number' => $msg['check_number'],
        'letter_code' => $msg['letter_code'],

        // API required fields
        'version' => '3'
    );

    watchdog( 'wmf_civicrm', 'Contribution array for civicrm_contribution_add(): ' . print_r($contribution, TRUE), NULL, WATCHDOG_DEBUG);

    $contribution_result = civicrm_api( "Contribution", "Create", $contribution );
    
    watchdog( 'wmf_civicrm', 'Contribution result from civicrm_contribution_add(): ' . print_r($contribution_result, TRUE), NULL, WATCHDOG_DEBUG);
    
    if ( array_key_exists( 'is_error', $contribution_result ) && $contribution_result['is_error'] != 0 ) {
        throw new WmfException(
            'INVALID_MESSAGE',
            'Cannot create contribution: ' . $contribution_result['error_message'],
            array('failed_contribution' => $contribution, 'msg' => $msg)
        );
    }
  
    /**
    *  Apply custom field defaults.
    *
    * Civicrm API v2 does NOT provide methods for custom groups/fields beyond creation and deleition,
    * so we hack this custom.  Hopefully this won't be forever...
    *
    * At least we can use the CiviCRM DAO stuff to stuff necessary custom data in to the contribution object.
    *
    * At the moment, all custom fields get default values for online contribution EXCEPT for 'Donor Comment'.
    *
    * NOTE: the custom field for "Gift_Information" indicates that check number is stored here.  It is not.
    */
    $dbs = wmf_civicrm_get_dbs();
    $dbs->use_civicrm();
    $query = "SELECT id, name, table_name FROM civicrm_custom_group WHERE extends='Contribution' && is_active='1';";
    $dao = CRM_Core_DAO::executeQuery( $query ); // Execute's query using CiviCRM data object stuff
    while ( $dao->fetch() ) {
        if ( $dao->name == 'Contribution_Comments' ) {
            $comment = ( isset( $msg[ 'comment' ] ) ) ? $msg[ 'comment'] : '';
            $query = "INSERT INTO {" . $dao->table_name . "} (entity_id, donor_comment) VALUES ( %d, '%s' )";
            db_query( $query, $contribution_result[ 'id' ], $comment );
        } elseif ( $dao->name == 'Gift_Data' ) {
            $lettercode = ( $msg[ 'letter_code' ] ) ? $msg[ 'letter_code'] : NULL;
            $query = "INSERT INTO {" . $dao->table_name . "} (entity_id, letter_code) VALUES ( %d, '%s' )";
            db_query( $query, $contribution_result[ 'id' ], $lettercode );
        } else { // if we dont make sure $dao->default_value has some value, Civi breaks when we try to insert
            $query = "INSERT INTO {" . $dao->table_name . "} (entity_id) VALUES (%d)";
            db_query( $query, $contribution_result[ 'id' ] );
        }
    }
    $dbs->use_default();
    return $contribution_result;
}

/**
 * @fixme TODO: make the v3 API calls use the wrapper function
 *
 * @param $type
 * @param $name
 * @return bool
 */
function wmf_civicrm_get_civi_id($type, $name)
{
    static $civi_ids = array();
    $params = array('name' => $name);
    $dummy = array();
    
    if(array_key_exists($type, $civi_ids) && array_key_exists($name, $civi_ids[$type])) {
        watchdog('wmf_civicrm', "Already looked up $type - $name. Returning id " . $civi_ids[$type][$name]);
        return $civi_ids[$type][$name];
    }

    switch ($type) {
        case 'contribution_type_id':
            //fixme: This is probably the upside-down way to do it. Really ought to go through the API.
            //
            require_once( drupal_get_path( 'module', 'civicrm' ) . '/../CRM/Contribute/BAO/ContributionType.php' );
            $result = CRM_Contribute_BAO_ContributionType::retrieve($params, $dummy);
            if (!is_null($result)){
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "Found id for contribution_type $name: " . $civi_ids[$type][$name]);
            } else {
                //make it. Or, throw an error here. Either way.
                //XXX nonono
                watchdog('wmf_civicrm', "Id for contribution_type $name not found. Creating...");
                $params['description'] = '';
                $params['accounting_code'] = strtoupper($name);
                $params['is_deductible'] = 1;
                $params['is_active'] = 1;
                $result = CRM_Contribute_BAO_ContributionType::add($params, $dummy);
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "New id for contribution_type $name :" . $civi_ids[$type][$name]);
            }
            $id = $civi_ids[$type][$name];
            if (empty($id)) {
                throw new WmfException("CIVI_CONFIG", t("Contribution Type '%name' not found!", array("%name" => $name)));
            }
            return $id;
        case 'payment_instrument_id':
            require_once 'api/v3/OptionValue.php';
            $group_id = civicrm_api3_option_value_get(
                array('option_group_name' => 'payment_instrument', 'label'=> $name, 'version' => '3'));
            if($group_id['count'] == 1){
                $civi_ids[$type][$name] = $group_id['values'][strval($group_id['id'])]['value'];
                watchdog('wmf_civicrm', "Found value for payment_instrument $name :" . $civi_ids[$type][$name]);
                return $civi_ids[$type][$name];
            } else {
                throw new WmfException("CIVI_CONFIG", t("Payment Instrument '%name' not found!", array("%name" => $name)));
            }
            break;
        case 'tag_id':
            require_once 'api/v3/Tag.php';
            $tag_id = civicrm_api3_tag_get(array('name'=> $name, 'version' => '3'));
            if (is_array($tag_id) && array_key_exists('id', $tag_id)){
                $civi_ids[$type][$name] = $tag_id['id'];
                watchdog('wmf_civicrm', "Found id for Entity Tag $name :" . $civi_ids[$type][$name]);
                return $civi_ids[$type][$name];
            } else {
                throw new WmfException("CIVI_CONFIG", t("Entity Tag '%name' not found!", array("%name" => $name)));
            }
        default:
            throw new WmfException("CIVI_CONFIG", t("Civi lookup for type '%type' not implemented", array("%type" => $type)));
    }
}

/**
 * Determines which civi-only payment instrument is appropriate for the current 
 * message, and resturns the civi payment instrument's human-readable display 
 * string (if it exists).   
 *
 * TODO lookup table
 */
function wmf_civicrm_get_message_payment_instrument( $msg )
{
    civicrm_initialize();

    $payment_instrument = null;
    
    if ( array_key_exists( 'payment_method', $msg ) && trim( $msg['payment_method'] ) != '' ){
    
        switch( strtolower( $msg[ 'payment_method' ] ) ){
            case 'check':
                $payment_instrument = 'Check';
                break;
            case 'bt':
                $payment_instrument = 'Bank Transfer';
                break;
            case 'cc':
                $payment_instrument = 'Credit Card';	
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'visa':
                        $payment_instrument .= ': Visa';
                        break;
                    case 'mc':
                        $payment_instrument .= ': MasterCard';
                        break;
                    case 'amex':
                        $payment_instrument .= ': American Express';
                        break;
                    case 'maestro':
                        $payment_instrument .= ': Maestro';
                        break;
                    case 'solo':
                        $payment_instrument .= ': Solo';
                        break;
                    case 'laser':
                        $payment_instrument .= ': Laser';
                        break;
                    case 'jcb':
                        $payment_instrument .= ': JCB';
                        break;
                    case 'discover':
                        $payment_instrument .= ': Discover';
                        break;
                    case 'cb':
                        $payment_instrument .= ': Carte Bleue';
                        break;
                }
                break;
            case 'dd':
                $payment_instrument = 'Direct Debit';
                break;
            case 'ew':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'ew_paypal':
                        $payment_instrument = 'Paypal';
                        break;
                    case 'ew_webmoney':
                        $payment_instrument = 'Webmoney';
                        break;
                    case 'ew_moneybookers':
                        $payment_instrument = 'Moneybookers';
                        break;
                    case 'ew_cashu':
                        $payment_instrument = 'Cashu';
                        break;
                    case 'ew_yandex':
                        $payment_instrument = 'Yandex';
                        break;
                }
                break;
            case 'obt':
                if ( strtolower( $msg['payment_submethod'] === 'bpay' ) ){
                    $payment_instrument = 'Bpay';
                }
                break;
            case 'rtbt':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'rtbt_nordea_sweden':
                        $payment_instrument = 'Nordea';
                        break;
                    case 'rtbt_ideal':
                        $payment_instrument = 'iDeal';
                        break;
                    case 'rtbt_enets':
                        $payment_instrument = 'Enets';
                        break;
                    case 'rtbt_sofortuberweisung':
                        $payment_instrument = 'Sofort';
                        break;
                    case 'rtbt_eps':
                        $payment_instrument = 'EPS';
                        break;
                }
                break;
            case 'cash':
                $payment_instrument = 'Cash';
                //'cash_boleto' - Only one right now. I assume there might be more later? 
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'cash_boleto': 
                        $payment_instrument = 'Boleto';
                        break;
                }
                break;	
            case 'payflowpro':
                if ( strtolower( $msg['gateway'] ) === 'payflowpro' ){
                    $payment_instrument = 'Credit Card';
                }
                break;
            case 'amazon':
                $payment_instrument = 'Amazon';
                break;
        }
        
    } else {
        //payment_method is not even in the message. Assume it's legacy... but we can tell some things about these, too...
        if ( array_key_exists( 'gateway', $msg ) && strtolower($msg['gateway']) === 'paypal' ){
            $payment_instrument = 'Paypal';
        }
    }
    
    if ($payment_instrument === null)
    {
        throw new WmfException("INVALID_MESSAGE", "No payment type found for message.", $msg);
    }

    //I was going to check to make sure the target gateway was a real thing, but: Hello, overhead. No.
    return $payment_instrument;
}

/**
 * Normalize contribution amounts
 * 
 * Do exchange rate conversions and set appropriate fields for CiviCRM
 * based on information contained in the message.
 * 
 * @param $msg
 * @return array
 */
function wmf_civicrm_normalize_contribution_amounts( $msg ) {
  $settlement_currency = wmf_civicrm_get_settlement_currency($msg);
  $settlement_convert = exchange_rate_convert($msg['original_currency'], 1, $msg['date']) / exchange_rate_convert($settlement_currency, 1, $msg['date']);

  // round the amounts and do exchange rate conversion
  $msg['fee'] = round( $msg['fee'] * $settlement_convert, 2 );
  $msg['gross'] = round( $msg['gross'] * $settlement_convert, 2 );
  $msg['net'] = round( $msg['net'] * $settlement_convert, 2 );
  $msg['currency'] = $settlement_currency;
  
  return $msg;
}

function wmf_civicrm_verify_message_and_stage($msg)
{
    if ( !is_array( $msg ) ) {
        $msg = json_decode($msg->body, true);
    }

    $required = array(
        'email',
        'gross',
        'original_currency',
        'gateway',
        'gateway_txn_id',
    );

    $err = array();
    foreach ($required as $key){
        if (!isset($msg[$key]) || $msg[$key] === ''){
            $err[] = "Required Field '$key' not found in message.";
        }
    }

    if(!array_key_exists('fee', $msg) && !array_key_exists('net', $msg)){
        $msg['fee'] = '0.00';
        $msg['net'] = $msg['gross'];
    } elseif(!array_key_exists('fee', $msg) && array_key_exists('net', $msg)){
        $msg['fee'] = $msg['gross'] - $msg['net'];
    } elseif(array_key_exists('fee', $msg) && !array_key_exists('net', $msg)){
        $msg['net'] = $msg['gross'] - $msg['fee'];
    }

    if (floatval($msg['net']) <= 0 || floatval($msg['gross']) <= 0)
    {
        $err[] = "Positive amount required.";
    }

    if (!empty($err)) {
        throw new WmfException('CIVI_REQ_FIELD', $err, $msg);
    }

    $msg['anonymous'] = (array_key_exists('anonymous', $msg) && $msg['anonymous'] == true && strtoupper($msg['anonymous']) != "FALSE") ? 1 : 0;
    $msg['optout'] = (array_key_exists('optout', $msg) && $msg['optout'] == true && strtoupper($msg['optout']) != "FALSE") ? 1 : 0;

    //defaults: Keys that aren't actually required, but which will cause some portion of the code to complain
    //if they don't exist (even if they're blank).
    $defaults = array(
        'date' => time(), //defaulting to now. @fixme: if you can think of a better thing to do in the name of historical exchange rates.
        'first_name' => 'Chester',
        'middle_name' => '',
        'last_name' => 'McDefault',
        'street_address' => '',
        'supplemental_address_1' => '',
        'city' => '',
        'country' => '',
        'state_province' => '',
        'postal_code' => '',
        'original_gross' => $msg['gross'],
    );

    $msg = wmf_civicrm_normalize_msg( array_merge($defaults, $msg) );

    // set the correct amount fields/data and do exchange rate conversions.
    $msg = wmf_civicrm_normalize_contribution_amounts( $msg );

    return $msg;
}

/**
 * Insert the contact record
 * 
 * Serves as a standard way for message processors to handle contact
 * insertion.  By passing a contact id, a contact can be updated.
 * 
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_insert( $msg, $contact_id=NULL ) {
    // Set defaults for optional fields in the message
    if ( !array_key_exists( 'contact_type', $msg ) ) {
        $msg['contact_type'] = "Individual";
    } elseif ( $msg['contact_type'] != "Individual" && $msg['contact_type'] != "Organization" ) {
        // looks like an unsupported type was sent, revert to default
        watchdog( 'wmf_civicrm', 'Non-supported contact_type received: %msg', array( '%msg' => print_r( $msg, true )), WATCHDOG_INFO );
        $msg['contact_type'] = "Individual";
    }

    if ( !array_key_exists( 'contact_source', $msg ) ) {
        $msg['contact_source'] = "online donation";
    }

    // Honor the opt-out checkbox, if present, else, set default
    if ( !array_key_exists( 'optout', $msg ) ) {
        $msg['optout'] = 0;
    }
  
    // Create the contact record
    $contact = array(
        'id' => $contact_id,
        'contact_type' => $msg['contact_type'],
        'first_name' => $msg['first_name'],
        'middle_name' => $msg['middle_name'],
        'last_name' => $msg['last_name'],
        'sort_name' => trim( $msg['last_name'] . ', ' . $msg['first_name'], ' ,' ),
        'display_name' => trim( $msg['first_name'] . ' ' . $msg['last_name'] ),
        'do_not_trade' => $msg['anonymous'],
        'is_opt_out' => $msg['optout'],
        'contact_source' => $msg['contact_source'],
        'preferred_language' => strtolower(substr($msg['language'], 0, 2)) . '_' . strtoupper(substr($msg['country'], 0, 2)),

        // API required fields
        'version' => '3'
    );
    if ( strtolower( $msg['contact_type'] ) == "organization" ){
        unset( $contact['first_name'] );
        unset( $contact['middle_name'] );
        unset( $contact['last_name'] );

        $contact['sort_name'] = $msg['organization_name'];
        $contact['display_name'] = $msg['organization_name'];
    }

    // Attempt to insert the contact
    $contact_result = civicrm_api( "Contact", "Create", $contact );

    if ( $contact_id == NULL ){
        watchdog( 'wmf_civicrm', 'Result for adding contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
    } else {
        watchdog( 'wmf_civicrm', 'Result for updating contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
    }

    if ( array_key_exists( 'is_error', $contact_result ) && $contact_result['is_error'] != 0 ){
        throw new WmfException("IMPORT_CONTACT", "Contact could not be added. Aborting import.");
    }
    return $contact_result;
}

/**
 * Update the contact record
 * 
 * Serves as a standard way for message processors to handle contact
 * updates.
 * 
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_update( $msg, $contact_id )
{
    return wmf_civicrm_message_contact_insert( $msg, $contact_id );
}

/**
 * Insert the location record
 * 
 * Serves as a standard way for message processors to handle location
 * insertion.
 * 
 * @param array $msg
 * @param array $contact
 * @return array
 */
function wmf_civicrm_message_location_insert( $msg, $contact ) {
    require_once 'api/v2/Location.php';
    $params = wmf_civicrm_message_location_prepare_params( $msg, $contact );
    $location_result = &civicrm_location_add( $params );
    watchdog( 'wmf_civicrm', 'Result for adding location: %location', array( '%location' => print_r( $location_result, true )), WATCHDOG_DEBUG );
    return $location_result;  
}

/**
 * Update the location record
 * 
 * Serves as a standard way for message processors to handle location
 * updates.
 * 
 * @param array $msg
 * @param array $contact
 * @return array
 * @fixme upgrade to API v3, Location is deprecated, use Address, Email, etc
 */
function wmf_civicrm_message_location_update( $msg, $contact ) {
      require_once 'api/v2/Location.php';
      $params = wmf_civicrm_message_location_prepare_params( $msg, $contact );
      $location_result = &civicrm_location_update( $params );
      watchdog( 'wmf_civicrm', 'Result for updating location: %location', array( '%location' => print_r( $location_result, true )), WATCHDOG_DEBUG );
      return $location_result;  
}

/**
 * Prepare the parameters for location adding/updating
 * 
 * @param $msg
 * @param $contact
 * @return array
 */
function wmf_civicrm_message_location_prepare_params( $msg, $contact ) {
    // unset the email address if the default is used
    // this enables us to properly dedupe contacts later on
    if( $msg[ 'email' ] == 'nobody@wikimedia.org' ){
        $msg[ 'email' ] = null;
    }

    //TODO lookup location_type
    $emails = array( 
        array(
            'email' => $msg[ 'email' ],
            'location_type_id' => 1,
        ) 
    );
    
    $address = array(
        1 => array(
            'location_type_id' => 1, //Home
            'is_primary' => 1,
            'street_address' => $msg['street_address'],
            'supplemental_address_1' => $msg['supplemental_address_1'],
            'city' => $msg['city'],
            'state_province' => wmf_civicrm_get_state( $msg[ 'country' ], $msg['state_province'] ),
            'postal_code' => $msg['postal_code'],
            'country' => $msg['country'],
            'is_billing' => 1,
        )
    );
    
    $params = array(
        'version' => '3.0',
        'contact_id' => $contact[ 'id' ],
        'address' => $address,
        'email' => $emails
    );
    
    return $params;
}

/**
 * Find correct state for insertion
 * 
 * When passing CiviCRM a state abbreviation, odd things can happen - like getting the right abbreviation, but the wrong state
 * So we'll pull back the correct state/province name based off of a user's country/state abbreviation
 */
function wmf_civicrm_get_state( $country, $state )
{
    if ( strlen( $country ) == 2 ) {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.iso_code='" . addslashes( $country ) . "' AND s.abbreviation='" . addslashes( $state ) . "'";
    } else {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.name='" . addslashes( $country ) . "' AND s.abbreviation='" . addslashes( $state ) . "'";
    }
    $dbs = wmf_civicrm_get_dbs();
    $dbs->use_civicrm();
    $result = db_query( $query );
    if ( $result->num_rows === 1 ){
      $row = db_fetch_object( $result );
      $state = $row->state_name;
    } 
    $dbs->use_default();
    
    return $state;
}


/**
 * Normalize the queued message
 * 
 * Decodes the message and updates some of the message fields in ways 
 * that are consistent with how we need to insert data into CiviCRM.
 * This should be useful by other modules processing contribution messages 
 * out of the queue.
 * 
 * @param mixed $msg
 * @return array
 */
function wmf_civicrm_normalize_msg( $msg ) {
    // Decode the message body.
    if ( !is_array( $msg ) ) {
        $msg = json_decode( $msg->body, true );
    }
    
    //handle the payment instrument without altering the original message
    //(just in case any downstream logic needs to switch on the raw data)
    $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument( $msg );

    // if we're missing a contrib id, insert new record to the table
    // this can happen if a user somehow makes a trxn from outside the normal workflow
    // checks are ignored as they were completely offline
    if ( !isset( $msg[ 'contribution_tracking_id' ] ) ) {
        if ( array_key_exists( 'payment_method', $msg ) && strtoupper( $msg['payment_method'] ) != "CHECK" ) {

            watchdog( 'wmf_civicrm', 'Contribution missing contribution_tracking_id', array(), WATCHDOG_DEBUG );
            //@fixme: For the regular transactions, this has been moved to the staging function. This needs to happen in recurring also, and then it can be removed here.
            $anonymous = ( array_key_exists( 'anonymous', $msg) && $msg['anonymous'] == true && strtoupper( $msg['anonymous'] ) != "FALSE" ) ? 1 : 0;
            $optout = ( array_key_exists( 'optout', $msg ) && $msg['optout'] == true && strtoupper( $msg['optout'] ) != "FALSE" ) ? 1 : 0;

            $contribution_tracking_id = wmf_civicrm_insert_contribution_tracking( '..' . $msg['payment_method'], 'civicrm', date('YmdHis', (int) $msg[ 'date' ] ), null, $optout, $anonymous ); //ACK! this should not be handled this way! should be dynamic!
            watchdog( 'wmf_civicrm', 'Newly inserted contribution tracking id: @id', array( '@id' => $contribution_tracking_id ), WATCHDOG_DEBUG );
            $msg['contribution_tracking_id'] = $contribution_tracking_id;
        }
    }

    // Convert times to Unix timestamps.
    if ( !is_numeric( $msg['date'] ) ) {
        $msg['date'] = strtotime($msg['date']);
    }
    // if all else fails, fall back to now.
    if ( empty( $msg['date'] ) ) {
        $msg['date'] = time();
    }

    watchdog( 'wmf_civicrm', 'Contribution (pre-conversion):<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>' );

    $msg[ 'gateway_txn_id_orig' ] = $msg[ 'gateway_txn_id' ];
    $msg['gateway_txn_id'] .= ' ' . time();

    return $msg;
}

/**
 * Insert the tag record
 * 
 * Serves as a standard way for message processors to handle tag
 * insertion.
 * 
 * @param array $contact
 * @return array
 */
function wmf_civicrm_tag_contact_for_review( $contact )
{
    require_once 'api/v2/EntityTag.php';

    $review_tag_id = wmf_civicrm_get_civi_id('tag_id', 'Review');

    $tag = array(
        'tag_id' => $review_tag_id,
        'contact_id' => $contact[ 'id' ]
    );
    $tag_result = civicrm_entity_tag_add( $tag );
    return $tag_result;
}
